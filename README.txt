CSE 373 Summer
July 14, 2017
@Author: Yeun-Yuan(Jessie) Kuo

1) Design Decision #1: 
   For my starting capacity, I went straight to using prime numbers, simply 
   because when you % numbers together, if you use prime, the resulting number 
   is less likely to be the same and so smaller bucket for each index on average.
   
   Design Decision #2: 
   Originally, I have 0.75, 1, 1.5, 2 in mind for my load factor. However, I
   settled on 0.75 because a nearly or entirely full table starts to exhibit
   poor performance(according to the textbook). Therefore, I choose to monitor 
   the table's size relative to the array capacity, and resize once this ratio 
   exceeds the threshold.
   
   Design Decision #3:
   For my new size of the array, I went straight to using prime numbers as well.
   The new size of my array should be a prime number closest to the double 
   of my current array size. Therefore, I kept a list of prime numbers for 
   resizing the table up once the load factor exceeds 0.75.
   
   
2) I choose to use the hashCode() in this project because hashCode() is 
   consistent in returning the same value each time, when given the same 
   object in the same state. Also, in our project we are not hashing multiple 
   things with different states, so using hashCode() is fine, otherwise I 
   would need to write my own hash function instead.
   
   
3) If I have to choose I would probably choose to use double hashing. Some of the 
   examples in how I would change my code: In my private hash function I would need 
   to change it so that it generates the number of h(key) + i*g(key) instead of 
   just one hash, and make sure that it never evaluates to 0. And I would also 
   need to change the addNewWord method so that instead of adding the current 
   word into a separate list, when adding a word I would need to probe through 
   the next index generated by hash function until I find a empty spot. And for 
   finding adding associations to a word, I will need to find the word by probing 
   through the indexes I went through previously when adding the word into the table, 
   and put that into the WordInfo of the word. For removing words I would also need to
   probe through the all the index that my hash function generates until I find my
   word and delete it. 

 
4) I spent 4 days on this project. I think the most challenging part is  
   where I need to resize the array to a bigger prime number and to rehash 
   all words to go exactly where I wanted. Also, writing MyClient.java to test 
   my TextAssociator is challenging too. The least challenging part would be
   choosing to use prime numbers as my array capacity choice.
   
   